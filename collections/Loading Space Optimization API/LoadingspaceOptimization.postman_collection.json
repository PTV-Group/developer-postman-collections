{
	"info": {
		"name": "PTV Developer Loading Space Optimization API",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Optimizing with focus",
			"item": [
				{
					"name": "Reduce Loading Meters",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"description": "Platform user identification.",
								"key": "ptv-user-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform product instance ID.",
								"key": "ptv-pi-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform roles map.",
								"key": "ptv-roles-map",
								"value": "",
								"disabled": true
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 244,\n                \"z\": 1360\n            },\n            \"maximumWeightCapacity\": 20000000\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"Large Packets\",\n            \"numberOfInstances\": 10,\n            \"dimensions\": {\n                \"x\": 120,\n                \"y\": 80,\n                \"z\": 180\n            },\n            \"weight\": 50000\n        },\n        {\n            \"id\": \"Small Packets\",\n            \"numberOfInstances\": 5,\n            \"dimensions\": {\n                \"x\": 120,\n                \"y\": 80,\n                \"z\": 30\n            },\n            \"weight\": 70000\n        },\n        {\n            \"id\": \"Quadratic Boxes\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 200,\n                \"y\": 200,\n                \"z\": 200\n            },\n            \"weight\": 800000,\n            \"maximumSurfaceLoads\": {\n                \"x\": 0,\n                \"y\": 0,\n                \"z\": 0\n            }\n        },\n        {\n            \"id\": \"Large Boxes\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 200,\n                \"y\": 240,\n                \"z\": 110\n            },\n            \"weight\": 1500000\n        }\n    ],\n    \"options\": {}\n}"
						},
						"url": {
							"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}?focus=REDUCE_LOADING_METERS",
							"protocol": "{{protocol}}",
							"host": [
								"{{hostname}}"
							],
							"path": [
								"{{apiprefix_binpacking}}"
							],
							"query": [
								{
									"key": "focus",
									"value": "REDUCE_LOADING_METERS"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Build layers",
					"request": {
						"method": "POST",
						"header": [
							{
								"description": "Platform user identification.",
								"key": "ptv-user-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform product instance ID.",
								"key": "ptv-pi-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform roles map.",
								"key": "ptv-roles-map",
								"value": "",
								"disabled": true
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 244,\n                \"z\": 1360\n            },\n            \"maximumWeightCapacity\": 20000000\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"Large Packets\",\n            \"numberOfInstances\": 10,\n            \"dimensions\": {\n                \"x\": 120,\n                \"y\": 80,\n                \"z\": 180\n            },\n            \"weight\": 50000\n        },\n        {\n            \"id\": \"Small Packets\",\n            \"numberOfInstances\": 5,\n            \"dimensions\": {\n                \"x\": 120,\n                \"y\": 80,\n                \"z\": 30\n            },\n            \"weight\": 70000\n        },\n        {\n            \"id\": \"Quadratic Boxes\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 200,\n                \"y\": 200,\n                \"z\": 200\n            },\n            \"weight\": 800000,\n            \"maximumSurfaceLoads\": {\n                \"x\": 0,\n                \"y\": 0,\n                \"z\": 0\n            }\n        },\n        {\n            \"id\": \"Large Boxes\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 200,\n                \"y\": 240,\n                \"z\": 110\n            },\n            \"weight\": 1500000\n        }\n    ],\n    \"options\": {}\n}"
						},
						"url": {
							"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}?focus=BUILD_LAYERS",
							"protocol": "{{protocol}}",
							"host": [
								"{{hostname}}"
							],
							"path": [
								"{{apiprefix_binpacking}}"
							],
							"query": [
								{
									"key": "focus",
									"value": "BUILD_LAYERS"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Optimizing with stackability",
			"item": [
				{
					"name": "All stackable",
					"request": {
						"method": "POST",
						"header": [
							{
								"description": "Platform user identification.",
								"key": "ptv-user-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform product instance ID.",
								"key": "ptv-pi-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform roles map.",
								"key": "ptv-roles-map",
								"value": "",
								"disabled": true
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 244,\n                \"z\": 1360\n            },\n            \"maximumWeightCapacity\": 20000000\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"Large Boxes\",\n            \"numberOfInstances\": 10,\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 120,\n                \"z\": 200\n            },\n            \"weight\": 1500000,\n            \"allowedOrientations\": [\n                \"ORIGINAL\"\n            ],\n            \"maximumSurfaceLoads\": {}\n        }\n    ],\n    \"options\": {}\n}"
						},
						"url": {
							"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}",
							"protocol": "{{protocol}}",
							"host": [
								"{{hostname}}"
							],
							"path": [
								"{{apiprefix_binpacking}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "All non-stackable",
					"request": {
						"method": "POST",
						"header": [
							{
								"description": "Platform user identification.",
								"key": "ptv-user-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform product instance ID.",
								"key": "ptv-pi-id",
								"value": "",
								"disabled": true
							},
							{
								"description": "Platform roles map.",
								"key": "ptv-roles-map",
								"value": "",
								"disabled": true
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 244,\n                \"z\": 1360\n            },\n            \"maximumWeightCapacity\": 20000000\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"Large Boxes\",\n            \"numberOfInstances\": 10,\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 120,\n                \"z\": 200\n            },\n            \"weight\": 1500000,\n            \"allowedOrientations\": [\n                \"ORIGINAL\"\n            ],\n            \"maximumSurfaceLoads\": {\n                \"x\": 0,\n                \"y\": 0,\n                \"z\": 0\n            }\n        }\n    ],\n    \"options\": {}\n}"
						},
						"url": {
							"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}",
							"protocol": "{{protocol}}",
							"host": [
								"{{hostname}}"
							],
							"path": [
								"{{apiprefix_binpacking}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Optimizing with orientation",
			"request": {
				"method": "POST",
				"header": [
					{
						"description": "Platform user identification.",
						"key": "ptv-user-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform product instance ID.",
						"key": "ptv-pi-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform roles map.",
						"key": "ptv-roles-map",
						"value": "",
						"disabled": true
					},
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"numberOfInstances\": 1,\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 244,\n                \"z\": 1360\n            },\n            \"maximumWeightCapacity\": 20000000\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"Box\",\n            \"numberOfInstances\": 10,\n            \"dimensions\": {\n                \"x\": 120,\n                \"y\": 80,\n                \"z\": 180\n            },\n            \"weight\": 1500000,\n            \"allowedOrientations\": [\n                \"ORIGINAL\",\n                \"X\",\n                \"Y\",\n                \"Z\",\n                \"XZ\",\n                \"YZ\"\n            ],\n            \"maximumSurfaceLoads\": {\n                \"x\": 0,\n                \"y\": 0,\n                \"z\": 0\n            }\n        }\n    ],\n    \"options\": {}\n}"
				},
				"url": {
					"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}?focus=REDUCE_LOADING_METERS",
					"protocol": "{{protocol}}",
					"host": [
						"{{hostname}}"
					],
					"path": [
						"{{apiprefix_binpacking}}"
					],
					"query": [
						{
							"key": "focus",
							"value": "REDUCE_LOADING_METERS"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Optimizing with unloading sequence",
			"request": {
				"method": "POST",
				"header": [
					{
						"description": "Platform user identification.",
						"key": "ptv-user-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform product instance ID.",
						"key": "ptv-pi-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform roles map.",
						"key": "ptv-roles-map",
						"value": "",
						"disabled": true
					},
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"numberOfInstances\": 1,\n            \"dimensions\": {\n                \"x\": 100,\n                \"y\": 100,\n                \"z\": 300\n            },\n            \"maximumWeightCapacity\": 25000000\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"BoxType 1\",\n            \"numberOfInstances\": 6,\n            \"dimensions\": {\n                \"x\": 50,\n                \"y\": 50,\n                \"z\": 50\n            },\n            \"weight\": 50000\n        },\n        {\n            \"id\": \"BoxType 2\",\n            \"numberOfInstances\": 6,\n            \"dimensions\": {\n                \"x\": 50,\n                \"y\": 50,\n                \"z\": 50\n            },\n            \"weight\": 50000\n        },\n        {\n            \"id\": \"BoxType 3\",\n            \"numberOfInstances\": 6,\n            \"dimensions\": {\n                \"x\": 50,\n                \"y\": 50,\n                \"z\": 50\n            },\n            \"weight\": 50000\n        }\n    ],\n    \"options\": {\n        \"unloadingSequence\": [\n            {\n                \"itemsToUnload\": [\n                    {\n                        \"itemId\": \"BoxType 1\",\n                        \"numberOfInstances\": 6\n                    }\n                ]\n            },\n            {\n                \"itemsToUnload\": [\n                    {\n                        \"itemId\": \"BoxType 2\",\n                        \"numberOfInstances\": 6\n                    }\n                ]\n            },\n            {\n                \"itemsToUnload\": [\n                    {\n                        \"itemId\": \"BoxType 3\",\n                        \"numberOfInstances\": 6\n                    }\n                ]\n            }\n        ]\n    }\n}"
				},
				"url": {
					"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}?focus=REDUCE_LOADING_METERS",
					"protocol": "{{protocol}}",
					"host": [
						"{{hostname}}"
					],
					"path": [
						"{{apiprefix_binpacking}}"
					],
					"query": [
						{
							"key": "focus",
							"value": "REDUCE_LOADING_METERS"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Optimizing with stacking restrictions",
			"request": {
				"method": "POST",
				"header": [
					{
						"description": "Platform user identification.",
						"key": "ptv-user-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform product instance ID.",
						"key": "ptv-pi-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform roles map.",
						"key": "ptv-roles-map",
						"value": "",
						"disabled": true
					},
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"numberOfInstances\": 1,\n            \"dimensions\": {\n                \"x\": 100,\n                \"y\": 100,\n                \"z\": 250\n            },\n            \"maximumWeightCapacity\": 25000000\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"BoxType 1\",\n            \"numberOfInstances\": 3,\n            \"dimensions\": {\n                \"x\": 30,\n                \"y\": 30,\n                \"z\": 30\n            },\n            \"weight\": 50000\n        },\n        {\n            \"id\": \"BoxType 2\",\n            \"numberOfInstances\": 3,\n            \"dimensions\": {\n                \"x\": 30,\n                \"y\": 30,\n                \"z\": 30\n            },\n            \"weight\": 50000\n        },\n        {\n            \"id\": \"BoxType 3\",\n            \"numberOfInstances\": 3,\n            \"dimensions\": {\n                \"x\": 30,\n                \"y\": 30,\n                \"z\": 30\n            },\n            \"weight\": 50000\n        }\n    ],\n    \"options\": {\n        \"stackingOptions\": {\n            \"stackingRestrictions\": [\n                {\n                    \"itemId\": \"BoxType 1\",\n                    \"restrictionType\": \"ALL_PROHIBITED\"\n                },\n                {\n                    \"itemId\": \"BoxType 2\",\n                    \"restrictionType\": \"ALL_PROHIBITED\"\n                },\n                {\n                    \"itemId\": \"BoxType 3\",\n                    \"restrictionType\": \"ALLOWED\",\n                    \"itemIds\": [\n                        \"BoxType 3\"\n                    ]\n                }\n            ]\n        }\n    }\n}"
				},
				"url": {
					"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}?focus=REDUCE_LOADING_METERS",
					"protocol": "{{protocol}}",
					"host": [
						"{{hostname}}"
					],
					"path": [
						"{{apiprefix_binpacking}}"
					],
					"query": [
						{
							"key": "focus",
							"value": "REDUCE_LOADING_METERS"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Start packing bins",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"BinPackingId\", pm.response.json().id);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"description": "Platform user identification.",
						"key": "ptv-user-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform product instance ID.",
						"key": "ptv-pi-id",
						"value": "",
						"disabled": true
					},
					{
						"description": "Platform roles map.",
						"key": "ptv-roles-map",
						"value": "",
						"disabled": true
					},
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"bins\": [\n        {\n            \"id\": \"Truck\",\n            \"dimensions\": {\n                \"x\": 240,\n                \"y\": 244,\n                \"z\": 1360\n            },\n            \"maximumWeightCapacity\": 20000000,\n            \"numberOfInstances\": 1\n        }\n    ],\n    \"items\": [\n        {\n            \"id\": \"Item 1\",\n            \"numberOfInstances\": 10,\n            \"dimensions\": {\n                \"x\": 120,\n                \"y\": 80,\n                \"z\": 180\n            },\n            \"weight\": 50000,\n            \"allowedOrientations\": [],\n            \"maximumSurfaceLoads\": null\n        },\n        {\n            \"id\": \"Item 2\",\n            \"numberOfInstances\": 5,\n            \"dimensions\": {\n                \"x\": 120,\n                \"y\": 80,\n                \"z\": 30\n            },\n            \"weight\": 70000,\n            \"allowedOrientations\": [],\n            \"maximumSurfaceLoads\": null\n        },\n        {\n            \"id\": \"Item 3\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 200,\n                \"y\": 200,\n                \"z\": 200\n            },\n            \"weight\": 800000,\n            \"allowedOrientations\": [],\n            \"maximumSurfaceLoads\": null\n        },\n        {\n            \"id\": \"Item 4\",\n            \"numberOfInstances\": 2,\n            \"dimensions\": {\n                \"x\": 200,\n                \"y\": 240,\n                \"z\": 110\n            },\n            \"weight\": 1500000,\n            \"allowedOrientations\": [],\n            \"maximumSurfaceLoads\": null\n        }\n    ],\n    \"options\": {}\n}"
				},
				"url": {
					"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking_async}}",
					"protocol": "{{protocol}}",
					"host": [
						"{{hostname}}"
					],
					"path": [
						"{{apiprefix_binpacking_async}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Cancel bin packing",
			"request": {
				"method": "DELETE",
				"header": [],
				"url": {
					"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}/{{BinPackingId}}",
					"protocol": "{{protocol}}",
					"host": [
						"{{hostname}}"
					],
					"path": [
						"{{apiprefix_binpacking}}",
						"{{BinPackingId}}"
					]
				},
				"description": "Performs a packing operation with unloading sequence"
			},
			"response": []
		},
		{
			"name": "Get status",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": ""
				},
				"url": {
					"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}/status/{{BinPackingId}}",
					"protocol": "{{protocol}}",
					"host": [
						"{{hostname}}"
					],
					"path": [
						"{{apiprefix_binpacking}}",
						"status",
						"{{BinPackingId}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Get packed bins",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": ""
				},
				"url": {
					"raw": "{{protocol}}://{{hostname}}/{{apiprefix_binpacking}}/{{BinPackingId}}",
					"protocol": "{{protocol}}",
					"host": [
						"{{hostname}}"
					],
					"path": [
						"{{apiprefix_binpacking}}",
						"{{BinPackingId}}"
					]
				}
			},
			"response": []
		}
	],
	"auth": {
		"type": "apikey",
		"apikey": [
			{
				"key": "value",
				"value": "{{ApiKey}}",
				"type": "string"
			},
			{
				"key": "key",
				"value": "ApiKey",
				"type": "string"
			}
		]
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					"var template = `",
					"    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css\">",
					"    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js\"></script>",
					"    <script src=\"https://rawgit.com/jeromeetienne/threex.domevents/master/threex.domevents.js\"></script>",
					"    <script src=\"https://code.jquery.com/jquery-3.5.1.min.js\"></script>",
					"    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js\"></script>",
					"    <style>",
					"      tbody, tr, th, td {",
					"        padding: 0;",
					"        white-space: nowrap;",
					"      }",
					"",
					"      .bintable {",
					"        height: 400px;",
					"        overflow: auto;",
					"        border: 1px solid lightgrey;",
					"      }",
					"",
					"      h1 {",
					"        text-align: center;",
					"      }",
					"      div.bin { }",
					"      div.bintable { float: left; width: 50%; }",
					"      div.binpicture { float: right; width: 50%; height: 400px}",
					"      div.packwidget { width: 100%; height: 100%}",
					"      div.clear { clear: both; }",
					"    </style>",
					"    <script type=\"text/javascript\">",
					"",
					"        // OrbitControls.js ----------------------------------------------------------------",
					"        ( function () {",
					"",
					"            function OrbitConstraint ( object ) {",
					"",
					"                this.object = object;",
					"",
					"                // \"target\" sets the location of focus, where the object orbits around",
					"                // and where it pans with respect to.",
					"                this.target = new THREE.Vector3();",
					"",
					"                // Limits to how far you can dolly in and out ( PerspectiveCamera only )",
					"                this.minDistance = 0;",
					"                this.maxDistance = Infinity;",
					"",
					"                // Limits to how far you can zoom in and out ( OrthographicCamera only )",
					"                this.minZoom = 0;",
					"                this.maxZoom = Infinity;",
					"",
					"                // How far you can orbit vertically, upper and lower limits.",
					"                // Range is 0 to Math.PI radians.",
					"                this.minPolarAngle = 0; // radians",
					"                this.maxPolarAngle = Math.PI; // radians",
					"",
					"                // How far you can orbit horizontally, upper and lower limits.",
					"                // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].",
					"                this.minAzimuthAngle = - Infinity; // radians",
					"                this.maxAzimuthAngle = Infinity; // radians",
					"",
					"                // Set to true to enable damping (inertia)",
					"                // If damping is enabled, you must call controls.update() in your animation loop",
					"                this.enableDamping = false;",
					"                this.dampingFactor = 0.25;",
					"",
					"                ////////////",
					"                // internals",
					"",
					"                var scope = this;",
					"",
					"                var EPS = 0.000001;",
					"",
					"                // Current position in spherical coordinate system.",
					"                var theta;",
					"                var phi;",
					"",
					"                // Pending changes",
					"                var phiDelta = 0;",
					"                var thetaDelta = 0;",
					"                var scale = 1;",
					"                var panOffset = new THREE.Vector3();",
					"                var zoomChanged = false;",
					"",
					"                // API",
					"",
					"                this.getPolarAngle = function () {",
					"",
					"                    return phi;",
					"",
					"                };",
					"",
					"                this.getAzimuthalAngle = function () {",
					"",
					"                    return theta;",
					"",
					"                };",
					"",
					"                this.rotateLeft = function ( angle ) {",
					"",
					"                    thetaDelta -= angle;",
					"",
					"                };",
					"",
					"                this.rotateUp = function ( angle ) {",
					"",
					"                    phiDelta -= angle;",
					"",
					"                };",
					"",
					"                // pass in distance in world space to move left",
					"                this.panLeft = function() {",
					"",
					"                    var v = new THREE.Vector3();",
					"",
					"                    return function panLeft ( distance ) {",
					"",
					"                        var te = this.object.matrix.elements;",
					"",
					"                        // get X column of matrix",
					"                        v.set( te[ 0 ], te[ 1 ], te[ 2 ] );",
					"                        v.multiplyScalar( - distance );",
					"",
					"                        panOffset.add( v );",
					"",
					"                    };",
					"",
					"                }();",
					"",
					"                // pass in distance in world space to move up",
					"                this.panUp = function() {",
					"",
					"                    var v = new THREE.Vector3();",
					"",
					"                    return function panUp ( distance ) {",
					"",
					"                        var te = this.object.matrix.elements;",
					"",
					"                        // get Y column of matrix",
					"                        v.set( te[ 4 ], te[ 5 ], te[ 6 ] );",
					"                        v.multiplyScalar( distance );",
					"",
					"                        panOffset.add( v );",
					"",
					"                    };",
					"",
					"                }();",
					"",
					"                // pass in x,y of change desired in pixel space,",
					"                // right and down are positive",
					"                this.pan = function ( deltaX, deltaY, screenWidth, screenHeight ) {",
					"",
					"                    if ( scope.object instanceof THREE.PerspectiveCamera ) {",
					"",
					"                        // perspective",
					"                        var position = scope.object.position;",
					"                        var offset = position.clone().sub( scope.target );",
					"                        var targetDistance = offset.length();",
					"",
					"                        // half of the fov is center to top of screen",
					"                        targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );",
					"",
					"                        // we actually don't use screenWidth, since perspective camera is fixed to screen height",
					"                        scope.panLeft( 2 * deltaX * targetDistance / screenHeight );",
					"                        scope.panUp( 2 * deltaY * targetDistance / screenHeight );",
					"",
					"                    } else if ( scope.object instanceof THREE.OrthographicCamera ) {",
					"",
					"                        // orthographic",
					"                        scope.panLeft( deltaX * ( scope.object.right - scope.object.left ) / screenWidth );",
					"                        scope.panUp( deltaY * ( scope.object.top - scope.object.bottom ) / screenHeight );",
					"",
					"                    } else {",
					"",
					"                        // camera neither orthographic or perspective",
					"                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );",
					"",
					"                    }",
					"",
					"                };",
					"",
					"                this.dollyIn = function ( dollyScale ) {",
					"",
					"                    if ( scope.object instanceof THREE.PerspectiveCamera ) {",
					"",
					"                        scale /= dollyScale;",
					"",
					"                    } else if ( scope.object instanceof THREE.OrthographicCamera ) {",
					"",
					"                        scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );",
					"                        scope.object.updateProjectionMatrix();",
					"                        zoomChanged = true;",
					"",
					"                    } else {",
					"",
					"                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );",
					"",
					"                    }",
					"",
					"                };",
					"",
					"                this.dollyOut = function ( dollyScale ) {",
					"",
					"                    if ( scope.object instanceof THREE.PerspectiveCamera ) {",
					"",
					"                        scale *= dollyScale;",
					"",
					"                    } else if ( scope.object instanceof THREE.OrthographicCamera ) {",
					"",
					"                        scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );",
					"                        scope.object.updateProjectionMatrix();",
					"                        zoomChanged = true;",
					"",
					"                    } else {",
					"",
					"                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );",
					"",
					"                    }",
					"",
					"                };",
					"",
					"                this.update = function() {",
					"",
					"                    var offset = new THREE.Vector3();",
					"",
					"                    // so camera.up is the orbit axis",
					"                    var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );",
					"                    var quatInverse = quat.clone().inverse();",
					"",
					"                    var lastPosition = new THREE.Vector3();",
					"                    var lastQuaternion = new THREE.Quaternion();",
					"",
					"                    return function () {",
					"",
					"                        var position = this.object.position;",
					"",
					"                        offset.copy( position ).sub( this.target );",
					"",
					"                        // rotate offset to \"y-axis-is-up\" space",
					"                        offset.applyQuaternion( quat );",
					"",
					"                        // angle from z-axis around y-axis",
					"",
					"                        theta = Math.atan2( offset.x, offset.z );",
					"",
					"                        // angle from y-axis",
					"",
					"                        phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );",
					"",
					"                        theta += thetaDelta;",
					"                        phi += phiDelta;",
					"",
					"                        // restrict theta to be between desired limits",
					"                        theta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );",
					"",
					"                        // restrict phi to be between desired limits",
					"                        phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );",
					"",
					"                        // restrict phi to be betwee EPS and PI-EPS",
					"                        phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );",
					"",
					"                        var radius = offset.length() * scale;",
					"",
					"                        // restrict radius to be between desired limits",
					"                        radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );",
					"",
					"                        // move target to panned location",
					"                        this.target.add( panOffset );",
					"",
					"                        offset.x = radius * Math.sin( phi ) * Math.sin( theta );",
					"                        offset.y = radius * Math.cos( phi );",
					"                        offset.z = radius * Math.sin( phi ) * Math.cos( theta );",
					"",
					"                        // rotate offset back to \"camera-up-vector-is-up\" space",
					"                        offset.applyQuaternion( quatInverse );",
					"",
					"                        position.copy( this.target ).add( offset );",
					"",
					"                        this.object.lookAt( this.target );",
					"",
					"                        if ( this.enableDamping === true ) {",
					"",
					"                            thetaDelta *= ( 1 - this.dampingFactor );",
					"                            phiDelta *= ( 1 - this.dampingFactor );",
					"",
					"                        } else {",
					"",
					"                            thetaDelta = 0;",
					"                            phiDelta = 0;",
					"",
					"                        }",
					"",
					"                        scale = 1;",
					"                        panOffset.set( 0, 0, 0 );",
					"",
					"                        // update condition is:",
					"                        // min(camera displacement, camera rotation in radians)^2 > EPS",
					"                        // using small-angle approximation cos(x/2) = 1 - x^2 / 8",
					"",
					"                        if ( zoomChanged ||",
					"                            lastPosition.distanceToSquared( this.object.position ) > EPS ||",
					"                            8 * ( 1 - lastQuaternion.dot( this.object.quaternion ) ) > EPS ) {",
					"",
					"                            lastPosition.copy( this.object.position );",
					"                            lastQuaternion.copy( this.object.quaternion );",
					"                            zoomChanged = false;",
					"",
					"                            return true;",
					"",
					"                        }",
					"",
					"                        return false;",
					"",
					"                    };",
					"",
					"                }();",
					"",
					"            };",
					"",
					"",
					"            // This set of controls performs orbiting, dollying (zooming), and panning. It maintains",
					"            // the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is",
					"            // supported.",
					"            //",
					"            //    Orbit - left mouse / touch: one finger move",
					"            //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish",
					"            //    Pan - right mouse, or arrow keys / touch: three finter swipe",
					"",
					"            THREE.OrbitControls = function ( object, domElement ) {",
					"",
					"                var constraint = new OrbitConstraint( object );",
					"",
					"                this.domElement = ( domElement !== undefined ) ? domElement : document;",
					"",
					"                // API",
					"",
					"                Object.defineProperty( this, 'constraint', {",
					"",
					"                    get: function() {",
					"",
					"                        return constraint;",
					"",
					"                    }",
					"",
					"                } );",
					"",
					"                this.getPolarAngle = function () {",
					"",
					"                    return constraint.getPolarAngle();",
					"",
					"                };",
					"",
					"                this.getAzimuthalAngle = function () {",
					"",
					"                    return constraint.getAzimuthalAngle();",
					"",
					"                };",
					"",
					"                // Set to false to disable this control",
					"                this.enabled = true;",
					"",
					"                // center is old, deprecated; use \"target\" instead",
					"                this.center = this.target;",
					"",
					"                // This option actually enables dollying in and out; left as \"zoom\" for",
					"                // backwards compatibility.",
					"                // Set to false to disable zooming",
					"                this.enableZoom = true;",
					"                this.zoomSpeed = 1.0;",
					"",
					"                // Set to false to disable rotating",
					"                this.enableRotate = true;",
					"                this.rotateSpeed = 1.0;",
					"",
					"                // Set to false to disable panning",
					"                this.enablePan = true;",
					"                this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push",
					"",
					"                // Set to true to automatically rotate around the target",
					"                // If auto-rotate is enabled, you must call controls.update() in your animation loop",
					"                this.autoRotate = false;",
					"                this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60",
					"",
					"                // Set to false to disable use of the keys",
					"                this.enableKeys = true;",
					"",
					"                // The four arrow keys",
					"                this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };",
					"",
					"                // Mouse buttons",
					"                this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };",
					"",
					"                ////////////",
					"                // internals",
					"",
					"                var scope = this;",
					"",
					"                var rotateStart = new THREE.Vector2();",
					"                var rotateEnd = new THREE.Vector2();",
					"                var rotateDelta = new THREE.Vector2();",
					"",
					"                var panStart = new THREE.Vector2();",
					"                var panEnd = new THREE.Vector2();",
					"                var panDelta = new THREE.Vector2();",
					"",
					"                var dollyStart = new THREE.Vector2();",
					"                var dollyEnd = new THREE.Vector2();",
					"                var dollyDelta = new THREE.Vector2();",
					"",
					"                var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };",
					"",
					"                var state = STATE.NONE;",
					"",
					"                // for reset",
					"",
					"                this.target0 = this.target.clone();",
					"                this.position0 = this.object.position.clone();",
					"                this.zoom0 = this.object.zoom;",
					"",
					"                // events",
					"",
					"                var changeEvent = { type: 'change' };",
					"                var startEvent = { type: 'start' };",
					"                var endEvent = { type: 'end' };",
					"",
					"                // pass in x,y of change desired in pixel space,",
					"                // right and down are positive",
					"                function pan( deltaX, deltaY ) {",
					"",
					"                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;",
					"",
					"                    constraint.pan( deltaX, deltaY, element.clientWidth, element.clientHeight );",
					"",
					"                }",
					"",
					"                this.update = function () {",
					"",
					"                    if ( this.autoRotate && state === STATE.NONE ) {",
					"",
					"                        constraint.rotateLeft( getAutoRotationAngle() );",
					"",
					"                    }",
					"",
					"                    if ( constraint.update() === true ) {",
					"",
					"                        this.dispatchEvent( changeEvent );",
					"",
					"                    }",
					"",
					"                };",
					"",
					"                this.reset = function () {",
					"",
					"                    state = STATE.NONE;",
					"",
					"                    this.target.copy( this.target0 );",
					"                    this.object.position.copy( this.position0 );",
					"                    this.object.zoom = this.zoom0;",
					"",
					"                    this.object.updateProjectionMatrix();",
					"                    this.dispatchEvent( changeEvent );",
					"",
					"                    this.update();",
					"",
					"                };",
					"",
					"                function getAutoRotationAngle() {",
					"",
					"                    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;",
					"",
					"                }",
					"",
					"                function getZoomScale() {",
					"",
					"                    return Math.pow( 0.95, scope.zoomSpeed );",
					"",
					"                }",
					"",
					"                function onMouseDown( event ) {",
					"",
					"                    if ( scope.enabled === false ) return;",
					"",
					"                    event.preventDefault();",
					"",
					"                    if ( event.button === scope.mouseButtons.ORBIT ) {",
					"",
					"                        if ( scope.enableRotate === false ) return;",
					"",
					"                        state = STATE.ROTATE;",
					"",
					"                        rotateStart.set( event.clientX, event.clientY );",
					"",
					"                    } else if ( event.button === scope.mouseButtons.ZOOM ) {",
					"",
					"                        if ( scope.enableZoom === false ) return;",
					"",
					"                        state = STATE.DOLLY;",
					"",
					"                        dollyStart.set( event.clientX, event.clientY );",
					"",
					"                    } else if ( event.button === scope.mouseButtons.PAN ) {",
					"",
					"                        if ( scope.enablePan === false ) return;",
					"",
					"                        state = STATE.PAN;",
					"",
					"                        panStart.set( event.clientX, event.clientY );",
					"",
					"                    }",
					"",
					"                    if ( state !== STATE.NONE ) {",
					"",
					"                        document.addEventListener( 'mousemove', onMouseMove, false );",
					"                        document.addEventListener( 'mouseup', onMouseUp, false );",
					"                        scope.dispatchEvent( startEvent );",
					"",
					"                    }",
					"",
					"                }",
					"",
					"                function onMouseMove( event ) {",
					"",
					"                    if ( scope.enabled === false ) return;",
					"",
					"                    event.preventDefault();",
					"",
					"                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;",
					"",
					"                    if ( state === STATE.ROTATE ) {",
					"",
					"                        if ( scope.enableRotate === false ) return;",
					"",
					"                        rotateEnd.set( event.clientX, event.clientY );",
					"                        rotateDelta.subVectors( rotateEnd, rotateStart );",
					"",
					"                        // rotating across whole screen goes 360 degrees around",
					"                        constraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );",
					"",
					"                        // rotating up and down along whole screen attempts to go 360, but limited to 180",
					"                        constraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );",
					"",
					"                        rotateStart.copy( rotateEnd );",
					"",
					"                    } else if ( state === STATE.DOLLY ) {",
					"",
					"                        if ( scope.enableZoom === false ) return;",
					"",
					"                        dollyEnd.set( event.clientX, event.clientY );",
					"                        dollyDelta.subVectors( dollyEnd, dollyStart );",
					"",
					"                        if ( dollyDelta.y > 0 ) {",
					"",
					"                            constraint.dollyIn( getZoomScale() );",
					"",
					"                        } else if ( dollyDelta.y < 0 ) {",
					"",
					"                            constraint.dollyOut( getZoomScale() );",
					"",
					"                        }",
					"",
					"                        dollyStart.copy( dollyEnd );",
					"",
					"                    } else if ( state === STATE.PAN ) {",
					"",
					"                        if ( scope.enablePan === false ) return;",
					"",
					"                        panEnd.set( event.clientX, event.clientY );",
					"                        panDelta.subVectors( panEnd, panStart );",
					"",
					"                        pan( panDelta.x, panDelta.y );",
					"",
					"                        panStart.copy( panEnd );",
					"",
					"                    }",
					"",
					"                    if ( state !== STATE.NONE ) scope.update();",
					"",
					"                }",
					"",
					"                function onMouseUp( /* event */ ) {",
					"",
					"                    if ( scope.enabled === false ) return;",
					"",
					"                    document.removeEventListener( 'mousemove', onMouseMove, false );",
					"                    document.removeEventListener( 'mouseup', onMouseUp, false );",
					"                    scope.dispatchEvent( endEvent );",
					"                    state = STATE.NONE;",
					"",
					"                }",
					"",
					"                function onMouseWheel( event ) {",
					"",
					"                    if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;",
					"",
					"                    event.preventDefault();",
					"                    event.stopPropagation();",
					"",
					"                    var delta = 0;",
					"",
					"                    if ( event.wheelDelta !== undefined ) {",
					"",
					"                        // WebKit / Opera / Explorer 9",
					"",
					"                        delta = event.wheelDelta;",
					"",
					"                    } else if ( event.detail !== undefined ) {",
					"",
					"                        // Firefox",
					"",
					"                        delta = - event.detail;",
					"",
					"                    }",
					"",
					"                    if ( delta > 0 ) {",
					"",
					"                        constraint.dollyOut( getZoomScale() );",
					"",
					"                    } else if ( delta < 0 ) {",
					"",
					"                        constraint.dollyIn( getZoomScale() );",
					"",
					"                    }",
					"",
					"                    scope.update();",
					"                    scope.dispatchEvent( startEvent );",
					"                    scope.dispatchEvent( endEvent );",
					"",
					"                }",
					"",
					"                function onKeyDown( event ) {",
					"",
					"                    if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;",
					"",
					"                    switch ( event.keyCode ) {",
					"",
					"                        case scope.keys.UP:",
					"                            pan( 0, scope.keyPanSpeed );",
					"                            scope.update();",
					"                            break;",
					"",
					"                        case scope.keys.BOTTOM:",
					"                            pan( 0, - scope.keyPanSpeed );",
					"                            scope.update();",
					"                            break;",
					"",
					"                        case scope.keys.LEFT:",
					"                            pan( scope.keyPanSpeed, 0 );",
					"                            scope.update();",
					"                            break;",
					"",
					"                        case scope.keys.RIGHT:",
					"                            pan( - scope.keyPanSpeed, 0 );",
					"                            scope.update();",
					"                            break;",
					"",
					"                    }",
					"",
					"                }",
					"",
					"                function touchstart( event ) {",
					"",
					"                    if ( scope.enabled === false ) return;",
					"",
					"                    switch ( event.touches.length ) {",
					"",
					"                        case 1:\t// one-fingered touch: rotate",
					"",
					"                            if ( scope.enableRotate === false ) return;",
					"",
					"                            state = STATE.TOUCH_ROTATE;",
					"",
					"                            rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );",
					"                            break;",
					"",
					"                        case 2:\t// two-fingered touch: dolly",
					"",
					"                            if ( scope.enableZoom === false ) return;",
					"",
					"                            state = STATE.TOUCH_DOLLY;",
					"",
					"                            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;",
					"                            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;",
					"                            var distance = Math.sqrt( dx * dx + dy * dy );",
					"                            dollyStart.set( 0, distance );",
					"                            break;",
					"",
					"                        case 3: // three-fingered touch: pan",
					"",
					"                            if ( scope.enablePan === false ) return;",
					"",
					"                            state = STATE.TOUCH_PAN;",
					"",
					"                            panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );",
					"                            break;",
					"",
					"                        default:",
					"",
					"                            state = STATE.NONE;",
					"",
					"                    }",
					"",
					"                    if ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );",
					"",
					"                }",
					"",
					"                function touchmove( event ) {",
					"",
					"                    if ( scope.enabled === false ) return;",
					"",
					"                    event.preventDefault();",
					"                    event.stopPropagation();",
					"",
					"                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;",
					"",
					"                    switch ( event.touches.length ) {",
					"",
					"                        case 1: // one-fingered touch: rotate",
					"",
					"                            if ( scope.enableRotate === false ) return;",
					"                            if ( state !== STATE.TOUCH_ROTATE ) return;",
					"",
					"                            rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );",
					"                            rotateDelta.subVectors( rotateEnd, rotateStart );",
					"",
					"                            // rotating across whole screen goes 360 degrees around",
					"                            constraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );",
					"                            // rotating up and down along whole screen attempts to go 360, but limited to 180",
					"                            constraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );",
					"",
					"                            rotateStart.copy( rotateEnd );",
					"",
					"                            scope.update();",
					"                            break;",
					"",
					"                        case 2: // two-fingered touch: dolly",
					"",
					"                            if ( scope.enableZoom === false ) return;",
					"                            if ( state !== STATE.TOUCH_DOLLY ) return;",
					"",
					"                            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;",
					"                            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;",
					"                            var distance = Math.sqrt( dx * dx + dy * dy );",
					"",
					"                            dollyEnd.set( 0, distance );",
					"                            dollyDelta.subVectors( dollyEnd, dollyStart );",
					"",
					"                            if ( dollyDelta.y > 0 ) {",
					"",
					"                                constraint.dollyOut( getZoomScale() );",
					"",
					"                            } else if ( dollyDelta.y < 0 ) {",
					"",
					"                                constraint.dollyIn( getZoomScale() );",
					"",
					"                            }",
					"",
					"                            dollyStart.copy( dollyEnd );",
					"",
					"                            scope.update();",
					"                            break;",
					"",
					"                        case 3: // three-fingered touch: pan",
					"",
					"                            if ( scope.enablePan === false ) return;",
					"                            if ( state !== STATE.TOUCH_PAN ) return;",
					"",
					"                            panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );",
					"                            panDelta.subVectors( panEnd, panStart );",
					"",
					"                            pan( panDelta.x, panDelta.y );",
					"",
					"                            panStart.copy( panEnd );",
					"",
					"                            scope.update();",
					"                            break;",
					"",
					"                        default:",
					"",
					"                            state = STATE.NONE;",
					"",
					"                    }",
					"",
					"                }",
					"",
					"                function touchend( /* event */ ) {",
					"",
					"                    if ( scope.enabled === false ) return;",
					"",
					"                    scope.dispatchEvent( endEvent );",
					"                    state = STATE.NONE;",
					"",
					"                }",
					"",
					"                function contextmenu( event ) {",
					"",
					"                    event.preventDefault();",
					"",
					"                }",
					"",
					"                this.dispose = function() {",
					"",
					"                    this.domElement.removeEventListener( 'contextmenu', contextmenu, false );",
					"                    this.domElement.removeEventListener( 'mousedown', onMouseDown, false );",
					"                    this.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );",
					"                    this.domElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox",
					"",
					"                    this.domElement.removeEventListener( 'touchstart', touchstart, false );",
					"                    this.domElement.removeEventListener( 'touchend', touchend, false );",
					"                    this.domElement.removeEventListener( 'touchmove', touchmove, false );",
					"",
					"                    document.removeEventListener( 'mousemove', onMouseMove, false );",
					"                    document.removeEventListener( 'mouseup', onMouseUp, false );",
					"",
					"                    window.removeEventListener( 'keydown', onKeyDown, false );",
					"",
					"                }",
					"",
					"                this.domElement.addEventListener( 'contextmenu', contextmenu, false );",
					"",
					"                this.domElement.addEventListener( 'mousedown', onMouseDown, false );",
					"                this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );",
					"                this.domElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox",
					"",
					"                this.domElement.addEventListener( 'touchstart', touchstart, false );",
					"                this.domElement.addEventListener( 'touchend', touchend, false );",
					"                this.domElement.addEventListener( 'touchmove', touchmove, false );",
					"",
					"                window.addEventListener( 'keydown', onKeyDown, false );",
					"",
					"                // force an update at start",
					"                this.update();",
					"",
					"            };",
					"",
					"            THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );",
					"            THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;",
					"",
					"            Object.defineProperties( THREE.OrbitControls.prototype, {",
					"",
					"                object: {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.object;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                target: {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.target;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        console.warn( 'THREE.OrbitControls: target is now immutable. Use target.set() instead.' );",
					"                        this.constraint.target.copy( value );",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                minDistance : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.minDistance;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.minDistance = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                maxDistance : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.maxDistance;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.maxDistance = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                minZoom : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.minZoom;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.minZoom = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                maxZoom : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.maxZoom;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.maxZoom = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                minPolarAngle : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.minPolarAngle;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.minPolarAngle = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                maxPolarAngle : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.maxPolarAngle;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.maxPolarAngle = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                minAzimuthAngle : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.minAzimuthAngle;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.minAzimuthAngle = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                maxAzimuthAngle : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.maxAzimuthAngle;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.maxAzimuthAngle = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                enableDamping : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.enableDamping;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.enableDamping = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                dampingFactor : {",
					"",
					"                    get: function () {",
					"",
					"                        return this.constraint.dampingFactor;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        this.constraint.dampingFactor = value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                // backward compatibility",
					"",
					"                noZoom: {",
					"",
					"                    get: function () {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );",
					"                        return ! this.enableZoom;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );",
					"                        this.enableZoom = ! value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                noRotate: {",
					"",
					"                    get: function () {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );",
					"                        return ! this.enableRotate;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );",
					"                        this.enableRotate = ! value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                noPan: {",
					"",
					"                    get: function () {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );",
					"                        return ! this.enablePan;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );",
					"                        this.enablePan = ! value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                noKeys: {",
					"",
					"                    get: function () {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );",
					"                        return ! this.enableKeys;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );",
					"                        this.enableKeys = ! value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                staticMoving : {",
					"",
					"                    get: function () {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );",
					"                        return ! this.constraint.enableDamping;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );",
					"                        this.constraint.enableDamping = ! value;",
					"",
					"                    }",
					"",
					"                },",
					"",
					"                dynamicDampingFactor : {",
					"",
					"                    get: function () {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );",
					"                        return this.constraint.dampingFactor;",
					"",
					"                    },",
					"",
					"                    set: function ( value ) {",
					"",
					"                        console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );",
					"                        this.constraint.dampingFactor = value;",
					"",
					"                    }",
					"",
					"                }",
					"",
					"            } );",
					"",
					"        }() );",
					"        // OrbitControls.js ----------------------------------------------------------------",
					"",
					"        // packWidget.js -------------------------------------------------------------------",
					"        /**",
					"         * Returns the position of an object with respect to the",
					"         * (0, 0, 0) coordinate of the object.",
					"         * @method positionWithPivot",
					"         * @param x x coordinate of the object",
					"         * @param y y coordinate of the object",
					"         * @param z z coordinate of the object",
					"         * @param width width of the object",
					"         * @param height height of the object",
					"         * @param depth depth of the object",
					"         * @return new position",
					"         **/",
					"        function positionWithPivot(x, y, z, width, height, depth) {",
					"        var newPosition = {",
					"            x: x + width/2.0,",
					"            y: y + height/2.0,",
					"            z: z + depth/2.0",
					"        };",
					"        return newPosition;",
					"        }",
					"",
					"        /**",
					"         * Returns the camera distance needed to fit an object to the screen",
					"         * @method fitObjToScreen",
					"         * @param fov Field of view of the camera",
					"         * @param aspect aspect ratio of the camera",
					"         * @param objWidth The width ob the object",
					"         * @param border left and right border in percent",
					"         * @return distance of camera",
					"         */",
					"        function fitObjToScreen(fov, aspect, objWidth, border) {",
					"            var width = objWidth + (objWidth/100.0)*border*2;",
					"            var distance = width/(2*aspect*Math.tan(((Math.PI*fov)/360)));",
					"            return distance;",
					"        }",
					"",
					"        /**",
					"         * Returns the total dimensions of multiple bins",
					"         * @method totalSize",
					"         * @param bins array with bin objects",
					"         * @return size object with x, y, z dimensions and center",
					"         */",
					"        function totalSize(bins) {",
					"        var size = {};",
					"        var xCoordinates = [];",
					"        var yCoordinates = [];",
					"        var zCoordinates = [];",
					"        bins.forEach(function (bin) {",
					"            xCoordinates.push(parseFloat(bin.x));",
					"            yCoordinates.push(parseFloat(bin.y));",
					"            zCoordinates.push(parseFloat(bin.z));",
					"        });",
					"        size.x = Math.max.apply(Math, xCoordinates);",
					"        size.x += parseFloat(bins[xCoordinates.indexOf(size.x)].width);",
					"        size.y = Math.max.apply(Math, yCoordinates);",
					"        size.y += parseFloat(bins[yCoordinates.indexOf(size.y)].height);",
					"        size.z = Math.max.apply(Math, zCoordinates);",
					"        size.z += parseFloat(bins[zCoordinates.indexOf(size.z)].depth);",
					"        size.center = {};",
					"        size.center.x = size.x/2;",
					"        size.center.y = size.y/2;",
					"        size.center.z = size.z/2;",
					"        return size;",
					"        }",
					"",
					"        /**",
					"         * Calculate the initial position of the camera based on the given options",
					"         * @method initialPosition",
					"         * @param options",
					"         * @param bins Array of Bin objects",
					"         * @return position of camera",
					"         */",
					"        function initialPosition(options, bins) {",
					"        options.rotateY = false;",
					"        var camera = new THREE.PerspectiveCamera(",
					"            options.fov, options.width/options.height, 0.1, 10000);",
					"        var distance = 0;",
					"        var position = {};",
					"        var size = totalSize(bins);",
					"        var minLength = Math.min(size.x, size.z);",
					"        var maxLength = Math.max(size.x, size.z);",
					"        var ratio = maxLength/minLength;",
					"        if (ratio < 2) {",
					"            options.rotateY = true;",
					"            if(size.x > size.z) {",
					"                var diag = size.z * Math.sqrt(2);",
					"                distance = fitObjToScreen(options.fov, options.width/options.height, diag, options.border);",
					"",
					"                camera.position.x =  size.center.x;",
					"                camera.position.z =   size.center.z + diag/2;",
					"                camera.position.y = size.center.y + size.y/2;",
					"                camera.lookAt(size.center);",
					"                camera.translateZ(distance);",
					"            } else {",
					"                var diag = size.x * Math.sqrt(2);",
					"                distance = fitObjToScreen(options.fov, options.width/options.height, diag, options.border);",
					"",
					"                camera.position.x =  size.center.x + diag/2;",
					"                camera.position.z =   size.center.z;",
					"                camera.position.y = size.center.y ;",
					"                camera.lookAt(size.center);",
					"                camera.translateZ(distance);",
					"            }",
					"        } else {",
					"            if(size.x > size.z) {",
					"                distance = fitObjToScreen(options.fov, options.width/options.height, size.x, options.border);",
					"",
					"                camera.position.x =  size.center.x;",
					"                camera.position.z =   size.center.z + size.z/2;",
					"                camera.position.y = size.center.y + size.y/2;",
					"                camera.lookAt(size.center);",
					"                camera.translateZ(distance);",
					"            } else {",
					"                distance = fitObjToScreen(options.fov, options.width/options.height, size.z, options.border);",
					"",
					"                camera.position.x =  size.center.x + size.x/2;",
					"                camera.position.z =   size.center.z;",
					"                camera.position.y = size.center.y ;",
					"                camera.lookAt(size.center);",
					"                camera.translateZ(distance);",
					"            }",
					"        }",
					"",
					"        position = camera.position;",
					"        position.center = size.center;",
					"        return position;",
					"        }",
					"",
					"        /**",
					"         * Creates a new item to be used with PackWidget",
					"         * @method Item",
					"         * @param x x coordinate of the item",
					"         * @param y y coordinate of the item",
					"         * @param z z coordinate of the item",
					"         * @param width width of the item",
					"         * @param height height of the item",
					"         * @param depth depth of the item",
					"         * @param holds the data from which the item was created, optional",
					"         */",
					"        var Item = function(x, y, z, width, height, depth, color, dataItem) {",
					"        this.x = x;",
					"        this.y = y;",
					"        this.z = z;",
					"        this.width = width;",
					"        this.height = height;",
					"        this.depth = depth;",
					"        this.color = color;",
					"        this.dataItem = dataItem;",
					"        this.visible = true;",
					"        this.data = dataItem;",
					"        this.graphicsItem = 0;",
					"        this.toString = function () {",
					"            return \"Position: \" + this.x + \" \" + this.y + \" \" + this.z +",
					"                \"Dimensions: \" + this.width + \" \"",
					"                + this.height + \" \" + this.depth;",
					"        };",
					"        };",
					"",
					"        /**",
					"         * Creates a new box shaped Bin.",
					"         * @param x x position of the bin",
					"         * @param y y position of the bin",
					"         * @param z z position of the bin",
					"         * @param width width of the bin",
					"         * @param height height of the bin",
					"         * @param depth depth of the bin",
					"         * @param color color of the bin in hex format",
					"         */",
					"        var Bin = function (x, y, z, width, height, depth, color) {",
					"        return new BinShaped(x, y, z, dimensionsToPath(width, height), depth, color);",
					"        };",
					"",
					"        function BinShaped(x, y, z, shape, depth, color) {",
					"            this.x = x;",
					"            this.y = y;",
					"            this.z = z;",
					"            this.color = color;",
					"            this.shape = shape;",
					"            this.width = Math.max.apply(null, shape.map(function(point) {",
					"                return point.x;",
					"            }));",
					"            this.height = Math.max.apply(null, shape.map(function(point) {",
					"                return point.y;",
					"            }));",
					"            this.depth = depth;",
					"            this.visible = true; ",
					"        }",
					"",
					"        /** Creates a camera to be used with PackWidget",
					"         * @method Camera",
					"         * @param position position of the camera",
					"         * @param target target the camera looks at",
					"         */",
					"        var Camera = function(position, target) {",
					"        this.position = position;",
					"        this.target = target;",
					"        this.toString = function() {",
					"            return \"Position: \" + position +",
					"                    \"Target:\" + target;",
					"        };",
					"        };",
					"",
					"        /** Creates the Widget object which is shown on the page",
					"         * After initialization create() must be called to actually",
					"         * show it.",
					"         * @method PackWidget",
					"         * @param bins bin objects",
					"         * @param items items of the scene",
					"         * @param userOptions options provided by the user",
					"         */",
					"        var PackWidget = function (bins, items, userOptions) {",
					"        this.mouse = new THREE.Vector2();",
					"        // this is a hack: serialize/deserialize userOptions to clone objects",
					"        this.userOptions = JSON.parse(JSON.stringify(userOptions));",
					"        this.bins = JSON.parse(JSON.stringify(bins));",
					"        this.items = JSON.parse(JSON.stringify(items));",
					"        this.itemMap = new Map();",
					"        this.onItemClick = function(item) {};",
					"        this.onItemOver = function(item) {};",
					"        this.onItemOut = function(item) {};",
					"        }",
					"",
					"",
					"        /** Creates sane default options",
					"         * @method createDefaultOptions",
					"         * @param bin the bin object which is used for determining the camera position",
					"         */",
					"        PackWidget.prototype.createDefaultOptions = function (bins) {",
					"        var defaultOptions = {",
					"            backgroundColor: 0xfffffff,",
					"            width: 640,",
					"            fov: 30,",
					"            border: 0,",
					"            height: 640,",
					"            //cameraPosition: {x: bin.height * 2, y: bin.height * 2, z: bin.height * 2},",
					"            //cameranTarget: {x: bin.width/2, y: bin.height/2, z: bin.depth/2},",
					"            cameraType: \"perspective\",",
					"            highlightColor: 0xff0000",
					"        };",
					"        return defaultOptions;",
					"        };",
					"",
					"        /** Creates a rect shaped path based on width and height",
					"         * @param width width of the path",
					"         * @param height height of the path",
					"         * @return path",
					"         */",
					"        function dimensionsToPath(width, height) {",
					"        return [{x: 0, y: 0}, {x: 0, y:height}, {x: width, y: height}, {x: width, y: 0}];",
					"        }",
					"",
					"        /** Creates the final options based on the default options and the user",
					"         * options.",
					"         * @method createOptions",
					"         * @param defaultOptions the default options",
					"         * @param userOptions the user options",
					"         * @return the final options",
					"         */",
					"        PackWidget.prototype.createOptions = function (bins, defaultOptions, userOptions) {",
					"        var options = defaultOptions;",
					"        for (opt in userOptions) {",
					"            options[opt] = userOptions[opt];",
					"        }",
					"        var pos = initialPosition(options, bins);",
					"        options.cameraPosition = pos;",
					"        options.cameraTarget = pos.center;",
					"        return options;",
					"        };",
					"",
					"        /**",
					"         * Creates the camera object for the THREE scene. Not meant to be",
					"         * called by the user.",
					"         * @param options options created by createOptions",
					"         * @return THREE camera object",
					"         */",
					"        PackWidget.prototype.createThreeCamera = function(options, bins) {",
					"        var camera;",
					"        if (options.cameraType == \"perspective\") {",
					"            camera = new THREE.PerspectiveCamera(",
					"            this.options.fov, this.options.width/this.options.height, 0.1, 10000);",
					"            camera.position.x = options.cameraPosition.x;",
					"            camera.position.y = options.cameraPosition.y;",
					"            camera.position.z = options.cameraPosition.z;",
					"        }",
					"        else if (options.cameraType == \"orthographic\") {",
					"            camera = new THREE.OrthographicCamera(this.options.width/-2,",
					"                        this.options.width/2, this.options.height/2,",
					"                        this.options.height/-2, 0.1, 10000);",
					"                        camera.position.x = options.cameraPosition.x;",
					"                        camera.position.y = options.cameraPosition.y;",
					"                        camera.position.z = options.cameraPosition.z;",
					"            camera.zoom = 0.5;",
					"            camera.updateProjectionMatrix();",
					"        }",
					"        camera.lookAt(options.cameraTarget.x,",
					"                        options.cameraTarget.y,",
					"                        options.cameraTarget.z);",
					"        // camera.lookAt(100, 1000, 100);",
					"        camera.updateProjectionMatrix();",
					"",
					"        return camera;",
					"        };",
					"",
					"        /**",
					"         * Creates lights for the THREE scene",
					"         * @method createThreeLights",
					"         * @param options created by createOptions",
					"         * @return array with light objects",
					"         */",
					"        PackWidget.prototype.createThreeLights = function(options) {",
					"        var lights = [];",
					"        var light = new THREE.DirectionalLight(0xffffff, 1.0);",
					"        light.position.set(0.8, 1, 0.7);",
					"        lights.push(light);",
					"        //light = new THREE.DirectionalLight(0xffffff, 1);",
					"        //light.position.set(-0.8, 1, -0.7);",
					"        //lights.push(light);",
					"        return lights;",
					"        };",
					"",
					"        /**",
					"         * Creates a groundplane graphics object for a given bin.",
					"         * @param bin ",
					"         * @return mesh of the ground plane",
					"         */",
					"        function createGroundPlane(bin) {",
					"            var yPoints = bin.shape.map(function(point) {",
					"                return point.y;",
					"            });",
					"            ",
					"            var minY = Math.min.apply(null, yPoints);",
					"            ",
					"            var groundPoints = [];",
					"            for(var i = 0; i < bin.shape.length; i++) {",
					"                if (bin.shape[i].y === minY)",
					"                    groundPoints.push(bin.shape[i]);",
					"            }",
					"            var xGroundPoints = groundPoints.map(function(point){return point.x;});",
					"            ",
					"            var minX = Math.min.apply(null, xGroundPoints);",
					"            var maxX = Math.max.apply(null, xGroundPoints);",
					"            var width = Math.abs(maxX - minX);",
					"            var geometry = new THREE.BoxGeometry(width, 5, bin.depth);",
					"            var material = new THREE.MeshBasicMaterial( {color: 0xaaaaaa} );",
					"            var cube = new THREE.Mesh( geometry, material );",
					"        ",
					"            var minXGroundPoint = Math.min.apply(null, xGroundPoints);",
					"            ",
					"            var pos = positionWithPivot(bin.x + minX, bin.y - 5.01, bin.z, width, 5, bin.depth);",
					"            cube.position.x = pos.x;",
					"            cube.position.y = pos.y;",
					"            cube.position.z = pos.z;",
					"            ",
					"            ",
					"            ",
					"            return cube;",
					"            ",
					"        }",
					"",
					"        /**",
					"         * create Bin graphics Objects ",
					"         */",
					"        PackWidget.prototype.createTempBins = function (bins) {",
					"            var binMeshs = [];",
					"",
					"                // call the correct Bin Constructor",
					"            for(var i = 0; i < bins.length; i++) {",
					"            if(bins[i].shape === undefined)",
					"                binMeshs.push(createTHREEBin(bins[i]));",
					"            else {",
					"                    binMeshs.push(createShapedTHREEBin(bins[i]));",
					"                    binMeshs.push(createGroundPlane(bins[i]));",
					"                }",
					"            }",
					"            return binMeshs;",
					"        };",
					"",
					"        /**",
					"         * Creates the THREE graphics objects (meshes) representing the items for",
					"         * usage with the THREE scene. Not meant to be called by the user.",
					"         * @method createThreeItems",
					"         * @param items to be represented",
					"         * @return graphics objects",
					"         */",
					"        PackWidget.prototype.createThreeItems = function(items) {",
					"        var cubes = [];",
					"        var edges = [];",
					"        for (var i = 0; i < items.length; i++) {",
					"            var geometry = new THREE.BoxGeometry(",
					"            items[i].width,",
					"            items[i].height,",
					"            items[i].depth);",
					"            var material = new THREE.MeshPhongMaterial({color:items[i].color});",
					"            var cube = new THREE.Mesh(geometry, material);",
					"",
					"            var pos = positionWithPivot(items[i].x, items[i].y, items[i].z,",
					"                                        items[i].width, items[i].height, items[i].depth);",
					"            cube.position.x = pos.x;",
					"            cube.position.y = pos.y;",
					"            cube.position.z = pos.z;",
					"            cubes.push(cube);",
					"            items[i].graphicsItem = cube;",
					"            this.itemMap.set(cube, items[i]);",
					"",
					"            edge = new THREE.EdgesHelper(cube, 0x000000);",
					"            edges.push(edge);",
					"        }",
					"        return cubes.concat(edges);",
					"        };",
					"",
					"        /**",
					"         * Creates the renderer for THREE. Not meant to be called by the user.",
					"         * @method createThreeRenderer",
					"         * @param options options created by createOptions",
					"         * @return THREE renderer",
					"         */",
					"        PackWidget.prototype.createThreeRenderer = function(options) {",
					"        var renderer = new THREE.WebGLRenderer({antialias:true});",
					"        renderer.setClearColor(options.backgroundColor);",
					"        renderer.setSize(this.options.width, this.options.height);",
					"        return renderer;",
					"        };",
					"",
					"        /**",
					"         * Created the THREE Scene of the given bins, items, camera and lights.",
					"         * Not meant to be called by the user.",
					"         * @method createThreeScene",
					"         * @param bins THREE graphics objects representing the bins.",
					"         * @param items THREE graphics objects representing the items.",
					"         * @param camera THREE camera object",
					"         * @param lights THREE light objects",
					"         * @return THREE scene.",
					"         */",
					"        PackWidget.prototype.createThreeScene = function(bins, items, camera, lights) {",
					"        var scene = new THREE.Scene();",
					"        for (var i = 0; i < bins.length; i++)",
					"            scene.add(bins[i]);",
					"        for (var i = 0; i < items.length; i++)",
					"            scene.add(items[i]);",
					"        scene.add(camera);",
					"        for (var i = 0; i < lights.length; i++)",
					"            scene.add(lights[i]);",
					"        return scene;",
					"        };",
					"",
					"        /** Creates a graphics object for a shaped bin",
					"         * @param bin",
					"         * @return bin mesh",
					"         **/",
					"        function createShapedTHREEBin(bin) {",
					"            var shape = new THREE.Shape();",
					"            for(var j = 0; j < bin.shape.length; j++) {",
					"            shape.moveTo(bin.shape[j].x,",
					"                    bin.shape[j].y);       ",
					"            }",
					"",
					"            var material = new THREE.MeshBasicMaterial({color: 0xff0000});",
					"            ",
					"            var settings = { wireframe: true, amount: bin.depth,",
					"                    bevelEnabled: false, bevelSegments: 1,",
					"                    steps: 1, bevelSize: 1, bevelThickness: 1 };",
					"            var geometry = new THREE.ExtrudeGeometry(shape, settings);",
					"            var mesh = new THREE.Mesh(geometry, material);",
					"        ",
					"",
					"            pos = positionWithPivot(bin.x, bin.y, bin.z,",
					"                        bin.width, bin.height, bin.depth);",
					"            mesh.position.x = pos.x;",
					"            mesh.position.y = pos.y;",
					"            mesh.position.z = pos.z;",
					"",
					"            edges = new THREE.EdgesHelper( mesh, bin.color);",
					"            edges.matrixAutoUpdate = true;",
					"",
					"",
					"            ",
					"            ",
					"            bin.graphicsItem = edges;",
					"",
					"            return edges;",
					"        }",
					"",
					"        /** Create a non shaped, box like Bin Graphics Object",
					"         * @param bin",
					"         */",
					"        function createTHREEBin(bin) {",
					"            var geometry = new THREE.BoxGeometry(",
					"            bin.width,",
					"            bin.height,",
					"            bin.depth",
					"            );",
					"",
					"            var material = new THREE.MeshBasicMaterial({color: bin.color});",
					"            var cube = new THREE.Mesh(geometry, material);",
					"",
					"            pos = positionWithPivot(bin.x, bin.y, bin.z,",
					"                                    bin.width, bin.height, bin.depth);",
					"            cube.position.x = pos.x;",
					"            cube.position.y = pos.y;",
					"            cube.position.z = pos.z;",
					"",
					"            var helper = new THREE.BoxHelper(cube);",
					"            helper.material.color.set(bin.color);",
					"            ",
					"            bin.graphicsItem = helper;",
					"",
					"            return helper;",
					"        }",
					"",
					"        /**",
					"         * Creates the widget and appends it to the dom element.",
					"         * @param container dom element",
					"         */",
					"        PackWidget.prototype.create = function (container) {",
					"",
					"        this.userOptions.width = container.offsetWidth;",
					"        this.userOptions.height = container.offsetHeight;",
					"        this.options = this.createOptions(this.bins,",
					"        this.createDefaultOptions(this.bins), this.userOptions);",
					"        ",
					"        var width = this.options.width;",
					"        var height = this.options.height;",
					"        var currentColor;",
					"        var raycaster = new THREE.Raycaster();",
					"        var rect = container.getBoundingClientRect();",
					"        var mouse = new THREE.Vector2();",
					"        var graphicsItems = this.createThreeItems(this.items);",
					"        //var graphicsBins = this.createThreeBins(this.bins);",
					"            //var graphicsBins = this.createThreeShapedBins(this.bins);",
					"            var graphicsBins = this.createTempBins(this.bins);",
					"        var camera = this.createThreeCamera(this.options, this.bins);",
					"",
					"        var lights = this.createThreeLights();",
					"        this.lights = lights;",
					"        var scene = this.createThreeScene(graphicsBins, graphicsItems, camera, lights);",
					"        scene.userData.element = container;",
					"        scene.userData.camera = camera;",
					"        scene.userData.lights = lights;",
					"        this.scene = scene;",
					"        scene.userData.itemMap = this.itemMap;",
					"",
					"            // add Threex Event Handlers for items",
					"        var domEvents = new THREEx.DomEvents(camera, scene.userData.element);",
					"",
					"            var itemClicked = this.onItemClick;",
					"            var itemOver = this.onItemOver;",
					"            var itemOut = this.onItemOut;",
					"",
					"            for (var i = 0; i < graphicsItems.length; i++) {",
					"            domEvents.bind(graphicsItems[i], 'click', function(item) {",
					"                itemClicked(scene.userData.itemMap.get(item.target));}, false);",
					"",
					"            domEvents.bind(graphicsItems[i], 'mouseover', function(item) {",
					"                itemOver(scene.userData.itemMap.get(item.target));}, false);",
					"",
					"            itemOut = this.onItemOut;",
					"            domEvents.bind(graphicsItems[i], 'mouseout', function(item) {",
					"                itemOut(scene.userData.itemMap.get(item.target));}, false);",
					"            }",
					"",
					"",
					"        scene.userData.controls = new THREE.OrbitControls(scene.userData.camera, scene.userData.element);",
					"        scene.userData.controls.target = this.options.cameraTarget;",
					"",
					"            var angle;",
					"        // if options.rotateY = true, look from a 45 degree angle",
					"        if (this.options.rotateY === true) {",
					"            angle = Math.PI/4;",
					"            scene.userData.controls.minAzimuthAngle = angle;",
					"            scene.userData.controls.maxAzimuthAngle = angle;",
					"            scene.userData.controls.update();",
					"            ",
					"            scene.userData.controls.minAzimuthAngle = -Math.PI;",
					"            scene.userData.controls.maxAzimuthAngle = Math.PI;",
					"            scene.userData.controls.update();",
					"        }",
					"        ",
					"        // camera looks down from a 45 degree angle",
					"        angle = Math.PI/4;",
					"        scene.userData.controls.minPolarAngle = angle;",
					"        scene.userData.controls.maxPolarAngle = angle;",
					"        scene.userData.controls.update();",
					"        scene.userData.controls.minPolarAngle = -Math.PI;",
					"        scene.userData.controls.maxPolarAngle = Math.PI;",
					"",
					"        // lock Rotation if options is set",
					"        if(this.options.verticalRotation === false) {",
					"            scene.userData.controls.maxAzimuthAngle = scene.userData.controls.getAzimuthAngle();",
					"            scene.userData.controls.minAzimuthAngle = scene.userData.controls.getAzimuthAngle();",
					"        }",
					"        if(this.options.horizontalRotation === false) {",
					"            scene.userData.controls.maxPolarAngle = scene.userData.controls.getPolarAngle();",
					"            scene.userData.controls.minPolarAngle = scene.userData.controls.getPolarAngle();",
					"        }",
					"",
					"",
					"        scene.userData.element.addEventListener('mousemove', onDocumentMouseMove, false);",
					"",
					"        function onDocumentMouseMove (event) {",
					"            event.preventDefault();",
					"            mouse.x = ((rect.left + event.clientX) / width) * 2 - 1;",
					"                    mouse.y = ((rect.top -event.clientY) / height) * 2 + 1;",
					"        }",
					"",
					"            // if it's the first widget create the renderer, if not just add it to the widgets",
					"        if(!this.widgetRenderer)",
					"            PackWidget.prototype.widgetRenderer = new PackWidgetRenderer();",
					"        this.widgetRenderer.widgets.push(this);",
					"        };",
					"",
					"        /** ",
					"         * Renderer for the Packwidgets",
					"         */",
					"        function PackWidgetRenderer() {",
					"            var canvas = document.createElement(\"canvas\");",
					"            canvas.style.position = 'fixed';",
					"            canvas.style.top = 0;",
					"            canvas.style.left = 0;",
					"            canvas.style.width = '100%';",
					"            canvas.style.height = '100%';",
					"            canvas.style.zIndex = -1;",
					"            document.body.appendChild(canvas);",
					"",
					"            var widgets = [];",
					"            this.widgets = widgets;",
					"            var renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});",
					"            renderer.setClearColor(0xffffff, 1);",
					"            renderer.setPixelRatio(window.devicePixelRatio);",
					"",
					"",
					"                // update size of the canvas element in case it was resized",
					"            function updateSize() {",
					"                var width = canvas.clientWidth;",
					"                var height = canvas.clientHeight;",
					"                if(canvas.width !== width || canvas.height !== height) {",
					"                    renderer.setSize(width, height, false);",
					"                }",
					"            }",
					"            ",
					"            var animate = function() {",
					"",
					"                render();",
					"                ",
					"                requestAnimationFrame(animate);",
					"            };",
					"",
					"            this.animate = animate;",
					"",
					"                // render canvas",
					"            function render() {",
					"                updateSize();",
					"                renderer.setClearColor(0xffffff);",
					"                renderer.enableScissorTest(false);",
					"                renderer.clear();",
					"",
					"                renderer.setClearColor(0xe0e0e0);",
					"                renderer.enableScissorTest(true);",
					"",
					"                widgets.forEach(function(widget) {",
					"",
					"                    // get viewport",
					"                    var element = widget.scene.userData.element;",
					"                    var rect = element.getBoundingClientRect();",
					"",
					"                    var width = rect.right - rect.left;",
					"                    var height = rect.bottom - rect.top;",
					"                    var left = rect.left;",
					"                    var bottom = renderer.domElement.clientHeight - rect.bottom;",
					"",
					"                    // check if it's offscreen. If so skip it",
					"                    if ( rect.bottom < 0 || rect.top  > renderer.domElement.clientHeight ||",
					"                        rect.right  < 0 || rect.left > renderer.domElement.clientWidth ) {",
					"                            return;",
					"                                }",
					"                            ",
					"                    renderer.setViewport(left, bottom, width, height);",
					"                    renderer.setScissor(left, bottom, width, height);",
					"                    ",
					"                    widget.scene.userData.camera.aspect = width / height;",
					"                    widget.scene.userData.camera.updateProjectionMatrix();",
					"                ",
					"                    widget.scene.userData.controls.update();",
					"                    widget.scene.userData.lights[0].position.set(widget.scene.userData.camera.position.x -",
					"                                                                widget.scene.userData.controls.target.x,",
					"                                                                widget.scene.userData.camera.position.y -",
					"                                                                widget.scene.userData.controls.target.y,",
					"                                                                widget.scene.userData.camera.position.z -",
					"                                                                widget.scene.userData.controls.target.z);",
					"",
					"                ",
					"                    renderer.render(widget.scene, widget.scene.userData.camera);",
					"                });",
					"",
					"            };",
					"            animate();",
					"        }",
					"        // packWidget.js -------------------------------------------------------------------",
					"",
					"        // mapping.js ----------------------------------------------------------------------",
					"        /**",
					"         * Maps given data to items specified by mapping",
					"         * @method mapItems",
					"         * @param data The data to be mapped",
					"         * @param The mapping object to be used",
					"         * @return the mapped items.",
					"         */",
					"        var mapItems = function(data, mapping) {",
					"        // var mapping = mapping;",
					"        var items = [];",
					"        for (var i = 0; i < data.length; i++) {",
					"            var element = data[i];",
					"",
					"            var properties = {};",
					"            for (m in mapping) {",
					"            properties[m] = traverseMapping(element, mapping[m], properties);",
					"            }",
					"            //console.log(properties);",
					"",
					"",
					"            var width, height, depth;",
					"",
					"            if(properties.x_length != undefined)",
					"            width = parseFloat(properties.x_length);",
					"            else",
					"            width = parseFloat(properties.x_end) - parseFloat(properties.x_start);",
					"",
					"            if(properties.y_length != undefined)",
					"            height = parseFloat(properties.y_length);",
					"            else",
					"            height = parseFloat(properties.y_end) - parseFloat(properties.y_start);",
					"",
					"            if(properties.z_length != undefined)",
					"            depth = parseFloat(properties.z_length);",
					"            else",
					"            depth = parseFloat(properties.z_end) - parseFloat(properties.z_start);",
					"",
					"            var color = parseInt(properties.color, 16);",
					"            var item = new Item(parseFloat(properties.x_start),",
					"                                parseFloat(properties.y_start),",
					"                                parseFloat(properties.z_start),",
					"                                width, height, depth, color, element);",
					"            items.push(item);",
					"        }",
					"        //console.log(items);",
					"        return items;",
					"        };",
					"",
					"        function mapBins(data, mapping) {",
					"            var bins = [];",
					"            for (var i = 0; i < data.length; i++) {",
					"                var element = data[i];",
					"                ",
					"                var properties = {};",
					"                for (m in mapping) {",
					"                    properties[m] = traverseMapping(element, mapping[m], properties);",
					"                }",
					"                ",
					"                var width, height, depth;",
					"                width = parseFloat(properties.x_length);",
					"                depth = parseFloat(properties.z_length);",
					"                height = parseFloat(properties.y_length);",
					"                var color = parseInt(properties.color, 16);",
					"            ",
					"                var shape = properties.shape;",
					"                var bin;",
					"                if(shape === undefined) {",
					"                bin = new Bin(parseFloat(properties.x_start),",
					"                        parseFloat(properties.y_start),",
					"                        parseFloat(properties.z_start),",
					"                        width, height, depth, color);",
					"                }",
					"                else {",
					"                bin = new BinShaped(parseFloat(properties.x_start),",
					"                            parseFloat(properties.y_start),",
					"                            parseFloat(properties.z_start),",
					"                            shape, depth, color);\t",
					"                }",
					"                bins.push(bin);",
					"            }",
					"            return bins;",
					"        }",
					"",
					"        /**",
					"         * This method finds the specific information in json data on the basis of the mapping. E.g. you need x,y coordinates from array with some POIs. data:{pos:[{xCoord:\"1\",yCoord:\"2\"}...]}",
					"         * @method traverseMapping",
					"         * @param root is the start parameter in json file. E.g. \"data\".",
					"         * @param mapping is the reference path to the target data. E.g. x = \"[\"pos\", \"xCoord\"]\"",
					"         * @return target the value of founded data. E.g. x = 1 or undefined",
					"         */",
					"        function traverseMapping (root, currentMap, properties) {",
					"        if (typeof currentMap == \"function\")",
					"            return currentMap(root);",
					"",
					"            if(currentMap == undefined)",
					"            return undefined;",
					"",
					"            if(typeof currentMap == 'number' || typeof currentMap == 'string') {",
					"            return currentMap;",
					"            }",
					"            var target, j;",
					"            target = root;",
					"            for (j = 0; j < currentMap.length; j++) {",
					"                target = target[currentMap[j]];",
					"            }",
					"            return target;",
					"        };",
					"        // mapping.js ----------------------------------------------------------------------",
					"",
					"        // packWidgetUtils.js --------------------------------------------------------------",
					"",
					"        /** Creates random items for testing purposes",
					"         * @method createRandomItems",
					"         * @param n number of items",
					"         * @param bin the bin which holds the items",
					"         * @param maxWidth max width of a single item",
					"         * @param maxHeight max height of a single item",
					"         * @param maxDepth max depth of a single item",
					"         * @return the created items",
					"         */",
					"        function tooltip(x, y, text, item) {",
					"        $('#pw-tooltip').data(\"item\", item);",
					"        ",
					"        if ($('#pw-tooltip').size() == 0) {",
					"            $(\"body\").append(\"<div style='position: fixed; pointerEvents: none; padding: 2px; zIndex: 2; border: 1px solid black; background: #FFF; color: #000;' id='pw-tooltip'></div>\");",
					"        }",
					"",
					"        $('#pw-tooltip').show().css('left', x + 'px').css('top', y + 'px').html(text);  ",
					"        }",
					"",
					"        function removeTooltip (item)",
					"        {",
					"        if ($('#pw-tooltip').data(\"item\") == item) {",
					"            $(\"#pw-tooltip\").hide();",
					"        }",
					"        }",
					"",
					"        /** Creates some random items for testing purposes",
					"         * @method createRandomItems",
					"         * @param n number of items",
					"         * @param n bin to determine coordinates from",
					"         * @param maxWidth max width of an item",
					"         * @param maxHeight max height of an item",
					"         * @param maxDepth max depth of an item",
					"         * @return item array",
					"         */",
					"        function createRandomItems(n, bin, maxWidth, maxHeight, maxDepth) {",
					"            var items = [];",
					"            for (var i = 0; i < n; i++) {",
					"                var itemWidth = Math.random() * maxWidth;",
					"                var itemHeight = Math.random() * maxHeight;",
					"                var itemDepth = Math.random() * maxDepth;",
					"                items[i] = {",
					"                x: (bin.x) + Math.random() * (bin.width - itemWidth),",
					"                y: (bin.y) + Math.random() * (bin.height - itemHeight),",
					"                z: (bin.z) + Math.random() * (bin.depth - itemDepth),",
					"                width: itemWidth,",
					"                height: itemHeight,",
					"                depth: itemDepth,",
					"                color: Math.random() * 0xffffff,",
					"                dataItem: null,",
					"                visible:true",
					"                };",
					"            }",
					"            return items;",
					"        }",
					"",
					"        /** Highlights an item with the given colorMask",
					"         * @method highlightItem",
					"         * @param item the item to be highlighted",
					"         * @param color the color the item should be highlighted",
					"         */",
					"        function highlightItem(item, color) {",
					"        item.graphicsItem.material.color.set(color);",
					"        }",
					"",
					"        /** Unhighlights an item",
					"         * @method unhighlightItem",
					"         * @param item the item to be unhighlighted",
					"         */",
					"        function unhighlightItem(item) {",
					"        item.graphicsItem.material.color.set(item.color);",
					"        }",
					"",
					"        /** makes a shape out of a rect and cutting lines",
					"         * @method cutout",
					"         * @param width width of the rect",
					"         * @param height height of the rect",
					"         * @param lines lines that cut the rect",
					"         * @return a path that describes the shape",
					"         */",
					"        function cutOut(width, height, lines) {",
					"        var shape = rectToShape(width, height);",
					"        var newLines = [];",
					"        ",
					"        if (lines !== undefined) {",
					"            for (var i = 0; i < lines.length; i++) { ",
					"            newLines[i] = {start: {x: lines[i][\"lat1\"], y: lines[i][\"height1\"]}, end: { x: lines[i][\"lat2\"], y: lines[i][\"height2\"]}};",
					"            }",
					"        }",
					"",
					"        for(var i = 0; i < newLines.length; i++) {",
					"            shape = cut(JSON.parse(JSON.stringify(shape)), newLines[i]);",
					"        }",
					"        ",
					"        return shape;",
					"        }",
					"",
					"        /** Cuts a shape with a single line",
					"         * @method cut",
					"         * @param shape",
					"         * @param line",
					"         * @return new shape",
					"         */",
					"        function cut(shape, line) {",
					"            var points;",
					"        ",
					"            shape = JSON.parse(JSON.stringify(shape));",
					"            var tempShape = [];// JSON.parse(JSON.stringify(shape));",
					"            shape.push(shape[0]);",
					"            for(var i = 0; i < shape.length - 1; i++) {",
					"            tempShape.push(shape[i]);",
					"            var result = checkLineIntersection(shape[i].x, shape[i].y, shape[i+1].x, shape[i+1].y,",
					"                            line.start.x, line.start.y, line.end.x, line.end.y);",
					"",
					"            if(result.intersects) {",
					"                points = line;",
					"                tempShape.push({x: result.x, y: result.y});",
					"            }",
					"            }",
					"",
					"            var newShape;",
					"            if(points !== undefined)",
					"            newShape = getNewShape(tempShape, points);",
					"            else",
					"            newShape = shape;",
					"            ",
					"            return newShape;",
					"        }",
					"",
					"        /** helper function to delete obsolete points from a shape cut by a line",
					"         * @param shape",
					"         * @param line",
					"         * @return ",
					"         */",
					"        function getNewShape(shape, line) {",
					"            var newShape = [];",
					"            for(var i = 0; i < shape.length; i++) {",
					"            if(!(isLeft(line.start, line.end, shape[i])))",
					"            newShape.push(shape[i]);",
					"            }",
					"",
					"            return newShape;",
					"        }",
					"",
					"        /** Checks if a is left of the line given by b and c",
					"         * @method isLeft",
					"         * @param a",
					"         * @param b",
					"         * @param c",
					"         * @return true if a is left, false otherwise",
					"         */",
					"        function isLeft(a, b, c) {",
					"            return ((b.x - a.x)*(c.y - a.y) -",
					"                (b.y - a.y)*(c.x - a.x)) > 0.1 ?",
					"                true : false;",
					"        }",
					"",
					"        /** Converts a rect to a shape",
					"         * @method rectToShape",
					"         * @param width width of the rect",
					"         * @param height height of the rect",
					"         * @return path of shapoe",
					"         */",
					"        function rectToShape(width, height) {",
					"            return [",
					"            {x: 0, y: 0},",
					"            {x: 0, y: height},",
					"            {x: width, y: height},",
					"            {x: width, y: 0}",
					"            ];",
					"        }",
					"",
					"        /** Checks if two lines intersect",
					"         * @param lineStartX",
					"         * @param lineStartY",
					"         * @param lineEndX",
					"         * @param lineEndY",
					"         * @param line2StartX",
					"         * @param line2StartY",
					"         * @param line2EndX",
					"         * @param line2EndY",
					"         * @return object width intersection point",
					"         */",
					"",
					"        function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {",
					"                var denominator, a, b, numerator1, numerator2, result = {",
					"                x: null,",
					"                y: null,",
					"                intersects: false",
					"                };",
					"            denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));",
					"            if (denominator == 0) {",
					"                return result;",
					"            }",
					"            a = line1StartY - line2StartY;",
					"            b = line1StartX - line2StartX;",
					"            numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);",
					"            numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);",
					"            a = numerator1 / denominator;",
					"            b = numerator2 / denominator;",
					"",
					"            // if we cast these lines infinitely in both directions, they intersect here:",
					"            result.x = line1StartX + (a * (line1EndX - line1StartX));",
					"            result.y = line1StartY + (a * (line1EndY - line1StartY));",
					"",
					"            // if line1 is a segment and line2 is infinite, they intersect if:",
					"            if (a > 0 && a < 1) {",
					"                result.intersects = true;",
					"            }",
					"            // if line2 is a segment and line1 is infinite, they intersect if:",
					"            if (b > 0 && b < 1) {",
					"                result.intersects = true;",
					"            }",
					"            // if line1 and line2 are segments, they intersect if both of the above are true",
					"            return result;",
					"        }",
					"        // packWidgetUtils.js --------------------------------------------------------------",
					"",
					"",
					"",
					"        function defaultOptions () {",
					"            return {",
					"            width: $(\".binpicture\").width(),",
					"            height: $(\".bintable\").height(),",
					"            backgroundColor: 0xeeeeee,",
					"            cameraType: \"perspective\",",
					"            horizontalRotation: true,",
					"            verticalRotation: true,",
					"            border: 40",
					"            };",
					"        }",
					"",
					"        function defaultColors () {",
					"            return [",
					"            \"0xdf7126\",\"0xd9a066\",\"0xeec39a\",\"0xfbf236\",",
					"            \"0x99e550\",\"0x6abe30\",\"0x37946e\",\"0x4b692f\",\"0x524b24\",\"0xe02f74\",\"0x30a082\",",
					"            \"0x639bff\",\"0x5ffe4\",\"0xcbfffc\",\"0x9badb7\",\"0x847eee\",\"0x696aee\",",
					"            \"0xee0000\",\"0x76428a\",\"0xac3232\",\"0xd95763\",\"0xd77bba\",\"0x8f974a\",\"0x8a6f30\",",
					"            \"0x22f4f1\",\"0x45283c\",\"0x663931\",\"0x8f563b\"",
					"            ];",
					"        }",
					"  ",
					"        function defaultMapping () {",
					"            var colors = defaultColors();",
					"            return {",
					"            \"x_start\": [\"z\"],",
					"            \"y_start\": [\"y\"],",
					"            \"z_start\": [\"x\"],",
					"            \"x_length\": [\"depth\"],",
					"            \"y_length\": [\"height\"],",
					"            \"z_length\": [\"width\"],",
					"            \"color\": function (item) {",
					"                return colors[item.nr % colors.length];",
					"            }",
					"            };",
					"        }",
					"        function binMapping () {",
					"        var colors = defaultColors();",
					"        return {",
					"            \"x_start\": [\"z\"],",
					"            \"y_start\": [\"y\"],",
					"            \"z_start\": [\"z\"],",
					"            \"x_length\": [\"depth\"],",
					"            \"y_length\": [\"height\"],",
					"            \"z_length\": [\"width\"],",
					"            \"color\": \"0xff0000\"",
					"            };",
					"        }",
					"",
					"        function colorColumn (actual, maximum) {",
					"            var util = Math.round(100 * actual / maximum);",
					"            return \"<td class='text-right' style='background-color: hsla(\" + util + \",100%,45%,0.8)'>\" +",
					"            (actual ? actual : \"\").toLocaleString() + \" / \" + (maximum ? maximum : \"\").toLocaleString() + \" (\" + util + \"%)</td>\";",
					"        }",
					"            ",
					"        function createBinStats(loadedBins, totalItems, div) {",
					"            $(div).append(\"<h2>Loaded containers</h2>\");",
					"            $(div).append(\"<table class='table table-bordered table-striped'><thead><th>#</th><th>Type</th><th>Length (m)</th><th>Height (m)</th><th>Width (m)</th><th>Loaded meters (m)</th><th>Loaded volume (m&sup3;)</th><th>Loaded weight (kg)</th><th>Loaded items</th></thead><tbody></tbody></table>\");",
					"",
					"            var tbody = $(\"tbody\", div);",
					"            var totalLoadedVolume = 0;",
					"            var totalVolumeCapacity = 0;",
					"            var totalWeightCapacity = 0;",
					"            var totalLoadedWeight = 0;",
					"            var totalLoadedItems = 0;",
					"",
					"            for (var i = 0; i < loadedBins.length; ++i) {",
					"                var d = loadedBins[i];",
					"                loadedBins[i].loaded_items = loadedBins[i].items.length;",
					"                loadedBins[i].loaded_volume = 0;",
					"                loadedBins[i].loaded_weight = 0;",
					"                for (var j = 0; j < loadedBins[i].items.length; ++j) {",
					"                    var item = loadedBins[i].items[j];",
					"                    loadedBins[i].loaded_volume += (item.width * item.height * item.depth) / 1000000;",
					"                    loadedBins[i].loaded_weight += item.weight;",
					"                }",
					"",
					"                var total_volume = (d.bin.width * d.bin.height * d.bin.depth) / 1000000;",
					"                ",
					"                var label = d.label;",
					"                if (label == undefined) {",
					"                    label = d.bin.type;",
					"                }",
					"",
					"                totalLoadedVolume += d.loaded_volume;",
					"                totalVolumeCapacity += total_volume;",
					"                totalWeightCapacity += d.bin.maxweight;",
					"                totalLoadedWeight += d.loaded_weight;",
					"                totalLoadedItems += d.loaded_items;",
					"                ",
					"                $(tbody).append(\"<tr>\" +",
					"                    \"<td class='text-right'>\" + (i + 1) + \"</td>\" +",
					"                    \"<td><a href='#bin\" + i + \"'><b>\" + label + \"</b></a></td>\" +",
					"                    \"<td class='text-right'>\" + d.bin.width / 100 +\"</td>\" +",
					"                    \"<td class='text-right'>\" + d.bin.height / 100 + \"</td>\" +",
					"                    \"<td class='text-right'>\" + d.bin.depth / 100 + \"</td>\" +",
					"                    colorColumn(d.bin.loading_meters_used, d.bin.loading_meters_total) +",
					"                    colorColumn(d.loaded_volume, total_volume) + ",
					"                    colorColumn(d.loaded_weight, d.bin.maxweight) + ",
					"                    \"<td class='text-right'>\" + d.loaded_items + \"</td>\" +",
					"                    \"</tr>\");",
					"            }",
					"            $(div).append(\"<h4>Totals loaded (\" +",
					"                \"weight: \" + totalLoadedWeight.toLocaleString() + \" / \" + totalWeightCapacity.toLocaleString() + \", \" +",
					"                \"volume: \" + totalLoadedVolume.toLocaleString() + \" / \" + totalVolumeCapacity.toLocaleString() + \", \" +",
					"                \"items: \" + totalLoadedItems.toLocaleString() + \" / \" + totalItems.toLocaleString() + \")</h4>\");            ",
					"        }",
					"",
					"        function createBinDiv(index, data, div) {",
					"            var label = data.label;",
					"            if (label == undefined) {",
					"            label = data.bin.label;",
					"            }",
					"            ",
					"            $(div).append(\"<h2><a name='bin\" + index + \"'></a>\" + label + \"</h2>\");",
					"            $(div).append(\"<div class='bin'></div>\");",
					"            var row = $(\".bin\", div);",
					"            $(row).",
					"            append(\"<div id='bintable\" + index + \"' class='bintable'></div>\").",
					"            append(\"<div id='binpicture\" + index + \"' class='binpicture'></div>\").",
					"            append(\"<div class='clear'></div>\");",
					"            ",
					"            createBinShortTable(data, $(\"#bintable\" + index));",
					"            createBinGraph(index, data, $(\"#binpicture\" + index));",
					"        }",
					"        ",
					"        function createBinGraph(index, data, div) {",
					"            $(div).append(\"<div id='pack\" + index + \"' class='packwidget'></div>\");",
					"",
					"            var items = mapItems(data.items, defaultMapping());",
					"            var bins = mapBins([data.bin], binMapping());",
					"            var packwidget = new PackWidget(bins, items, defaultOptions());",
					"            packwidget.onItemOver = function(item) { if (item) {highlightItem(item, \"#F00\"); tooltip(mouse.x, mouse.y , item.dataItem.label, item); } };",
					"            packwidget.onItemOut = function(item) { if (item) { removeTooltip(item); unhighlightItem(item); } };",
					"            packwidget.create($(\"#pack\" + index).get(0));",
					"        }",
					"",
					"        function createBinShortTable(data, div) {",
					"            $(div).append(\"<table class='table table-bordered table-striped'>\" +",
					"                        \"<thead><th>#</th><th>Label</th><th>Amount</th><th>Length (m)</th><th>Height (m)</th><th>Width (m)</th><th>Weight (kg)</th></thead>\" +",
					"                        \"<tbody></tbody></table>\" + ",
					"                        \"<a href='#'>[top]</a>\");",
					"",
					"            var tbody = $(\"tbody\", div);",
					"            var items = [];",
					"            for (var i = 0; i < data.items.length; ++i) {",
					"                var d = data.items[i];",
					"                if (items[d.nr]) {",
					"                    items[d.nr].amount++;",
					"                } else {",
					"                    items[d.nr] = { \"label\": d.label, \"width\": d.width / 100, \"height\": d.height / 100, \"depth\": d.depth / 100, \"weight\": d.weight, \"amount\": 1};",
					"                }",
					"            }",
					"",
					"            for(var id in items) {",
					"                var d = items[id];        ",
					"                $(tbody).append(\"<tr><td class='text-right'>\" + id + \"</td><td>\" + d.label + \"</td>\" +",
					"                    \"<td class='text-right'>\" + d.amount + \"</td>\" +",
					"                    \"<td class='text-right'>\" + d.width +\"</td><td class='text-right'>\" + d.height + \"</td><td class='text-right'>\" + d.depth + \"</td><td class='text-right'>\" + d.weight + \"</td></tr>\");",
					"            }",
					"        }",
					"        ",
					"        function createOffLoadedStats(data, div) {",
					"            $(div).append(\"<h2>OffLoaded items</h2>\");",
					"            $(div).append(\"<table class='table table-bordered table-striped'>\" +",
					"                        \"<thead><th>Type</th><th>Amount</th><th>Length (m)</th><th>Height (m)</th><th>Width (m)</th><th>Weight (kg)</th></thead>\" +",
					"                        \"<tbody></tbody></table>\" + ",
					"                        \"<a href='#'>[top]</a>\");",
					"",
					"            var tbody = $(\"tbody\", div);",
					"            for(var i = 0; i < data.length; ++i) {",
					"                var d = data[i];        ",
					"                $(tbody).append(\"<tr><td class='text-right'>\" + d.label + \"</td>\" +",
					"                    \"<td class='text-right'>\" + d.amount + \"</td>\" +",
					"                    \"<td class='text-right'>\" + d.width +\"</td><td class='text-right'>\" + d.height + \"</td><td class='text-right'>\" + d.depth + \"</td><td class='text-right'>\" + d.weight + \"</td></tr>\");",
					"            }",
					"        ",
					"        }",
					"        var mouse = {};",
					"        document.onmousemove = function(e) {",
					"            mouse.x = e.clientX;",
					"            mouse.y = e.clientY;",
					"        }",
					"",
					"        pm.getData( function(err, value){ ",
					"            var loadedBins = value.data.loadedBins;",
					"            var offloadedItems = value.data.offloadedItems;",
					"            var totalItems = value.data.totalItems;",
					"            $(\"body\").append(\"<div class='container-fluid' id='containers'></div>\");",
					"            $(\"#containers\").append(\"<div id='stats'></div>\");",
					"            $(\"#stats\").append(\"<div id='binstats'></div>\");",
					"            createBinStats(loadedBins, totalItems, \"#binstats\");",
					"",
					"            $(\"#containers\").append(\"<div style='margin-bottom: 25px'><hr /></div>\");",
					"",
					"            for (var i = 0; i < loadedBins.length; ++i) {",
					"                $(\"#containers\").append(\"<div id='bin\" + i + \"'></div>\");",
					"                createBinDiv(i, loadedBins[i], \"#bin\" + i);",
					"            }",
					"",
					"            if (offloadedItems.length != 0) {",
					"                $(\"#containers\").append(\"<div style='margin-bottom: 25px'><hr /></div>\");",
					"                $(\"#containers\").append(\"<div id='offloadedStats'></div>\");",
					"                createOffLoadedStats(offloadedItems, \"#offloadedStats\");",
					"            }",
					"        });",
					"     </script>",
					"`;",
					"",
					"var convert_to_visualizer_input = function(request, response) {",
					"    var loadedBins = []",
					"    var offloadedItems = [];",
					"    var totalItems = 0;",
					"",
					"    var bins = {};",
					"    for (var i = 0; i < request.bins.length; ++i) {",
					"        var bin = request.bins[i];",
					"        bins[bin.id] = i;",
					"        bin.nr = i;",
					"    }",
					"",
					"    var items = {};",
					"    for (var i = 0; i < request.items.length; ++i) {",
					"        var item = request.items[i];",
					"        items[item.id] = i;",
					"        item.nr = i;",
					"    }",
					"",
					"    if (response.packedBins) {",
					"        for (var bi = 0; bi < response.packedBins.length; ++bi) {",
					"            var binData = {};",
					"            var packedBin = response.packedBins[bi];",
					"            var bin = request.bins[bins[packedBin.binId]];",
					"",
					"            binData[\"bin\"] = {",
					"                label: \"Bin \" + (bi + 1) + \" (\" + packedBin.binId + \")\",",
					"                type: packedBin.binId,",
					"                x: 0,",
					"                y: 0,",
					"                z: 0,",
					"                width: bin.dimensions.x,",
					"                height: bin.dimensions.y,",
					"                depth: bin.dimensions.z,",
					"                loading_meters_total: bin.dimensions.z / 100,",
					"                loading_meters_used: packedBin.loadingMeters,",
					"                maxweight: bin.maximumWeightCapacity / 1000.0",
					"            };",
					"            binData[\"items\"] = [];",
					"            binData[\"accumulatedItems\"] = [];",
					"            if (packedBin.packedItems) {",
					"                for (var ii = 0; ii < packedBin.packedItems.length; ++ii) {",
					"                    var packedItem = packedBin.packedItems[ii];",
					"                    var item = request.items[items[packedItem.itemId]];",
					"                    var itemData = {",
					"                        label: packedItem[\"itemId\"],",
					"                        nr: item.nr,",
					"                        x: packedItem.position.x,",
					"                        y: packedItem.position.y,",
					"                        z: packedItem.position.z,",
					"                        width: packedItem.dimensions.x,",
					"                        height: packedItem.dimensions.y,",
					"                        depth: packedItem.dimensions.z,",
					"                        weight: item.weight / 1000.0",
					"                    };",
					"                    ++totalItems;",
					"                    binData.items.push(itemData);",
					"                }",
					"            }",
					"            loadedBins.push(binData);",
					"        }",
					"        if (response.itemsNotPacked) {",
					"            for (var i = 0; i < response.itemsNotPacked.length; ++i) {",
					"                var itemNotPacked = response.itemsNotPacked[i];",
					"                var initialItem = request.items[items[itemNotPacked.id]];",
					"                var offloadedItem = {",
					"                    label: itemNotPacked.id,",
					"                    width: initialItem.dimensions.x,",
					"                    height: initialItem.dimensions.y,",
					"                    depth: initialItem.dimensions.z,",
					"                    weight: initialItem.weight,",
					"                    amount: itemNotPacked.numberOfInstances",
					"                };",
					"                totalItems += itemNotPacked.numberOfInstances;",
					"                offloadedItems.push(offloadedItem);",
					"            }",
					"        }",
					"    }",
					"",
					"    return {",
					"        loadedBins: loadedBins,",
					"        offloadedItems: offloadedItems,",
					"        totalItems: totalItems",
					"    }",
					"};",
					"",
					"// Set visualizer",
					"try {",
					"    pm.visualizer.set(template, {",
					"        data: convert_to_visualizer_input(JSON.parse(pm.request.body.raw), pm.response.json())",
					"    });",
					"} catch (e) {}"
				]
			}
		}
	],
	"variable": [
		{
			"key": "baseUrl",
			"value": "127.0.0.1:2020"
		},
		{
			"key": "endpoint",
			"value": "api/bins"
		},
		{
			"key": "endpointasync",
			"value": "api/bins/async"
		},
		{
			"key": "BinPackingId",
			"value": ""
		}
	]
}